---
title:  "[개념공부] 선택정렬, 버블정렬"
permalink: /categories/algo_study/ssbs
author_profile: true
categories:
  - 알고리즘 개념 정리
tags:
  - 알고리즘 개념 정리
toc: true
toc_label: "목차"
toc_icon: "bookmark"
last_modified_at: 2023-01-28
toc_sticky: true
---

 이번 포스팅에서는 여러가지 정렬 알고리즘 중 **선택정렬**과 **버블정렬**에 대해 알아보겠다.



### 선택 정렬

> 입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법인 제자리 정렬 알고리즘 중의 하나로, 다음과 같은 순서로 이루어진다.

1. 주어진 리스트 중에 최소값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)).
3. 맨 처음 위치를 뺀 나머지 리스트에서 1, 2를 반복적으로 수행한다.

![img](../../assets/images/selection-sort.png)



#### 선택 정렬(selection sort) 알고리즘의 특징

- 장점
  - 자료 이동 횟수가 미리 결정된다.
- 단점
  - 안정성을 만족하지 않는다.
  - 즉, 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다.



#### 선택 정렬(selection sort)의 시간복잡도

시간복잡도를 계산한다면

- 비교 횟수
  - 두 개의 for 루프의 실행 횟수
  - 외부 루프: (n-1)번
  - 내부 루프(최솟값 찾기): n-1, n-2, … , 2, 1 번
- 교환 횟수
  - 외부 루프의 실행 횟수와 동일. 즉, 상수 시간 작업
  - 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 3(n-1)번
- T(n) = (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = O(n^2)
- 참고 [https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html](https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html)



#### 선택 정렬 js 코드

```js
function solution(arr){
    let answer=arr;
    for (let i = 0; i < arr.length; i++) {
        let minIdx = i
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIdx]) minIdx = j
        }
        [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
    }
    return answer;
}

let arr=[13, 5, 11, 7, 23, 15];
console.log(solution(arr));
```

----



### 버블 정렬

>  [정렬 알고리즘](https://ko.wikipedia.org/wiki/정렬_알고리즘) 중 하나이다. 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어진 이름이다. 기본적으로 배열의 두 수(a, b)를 선택한 뒤, 만약 그 두 수가 정렬되었다면 놔두고 아니라면 두 수를 바꾸는 방식으로 진행된다. 오름차순으로 정렬할 때는 a <  b여야  내림차순이라면 a > b여야 정렬된 것으로 판단한다.



#### 버블 정렬의 구체적인 개념

- 버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
- **1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동**하므로 **2회전에서는 맨 끝에 있는 자료는 정렬에서 제외**되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

![img](../../assets/images/bubble-sort.png)



#### 버블 정렬(bubble sort) 알고리즘의 특징

- 장점
  - 구현이 매우 간단하다.
- 단점
  - 순서에 맞지 않은 요소를 인접한 요소와 교환한다.
  - 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
  - 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.
- 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 **더 복잡**하기 때문에 버블 정렬은 단순성에도 불구하고 **거의 쓰이지 않는다**.



#### 버블 정렬(bubble sort)의 시간복잡도

시간복잡도를 계산한다면

- 비교 횟수
  - 최상, 평균, 최악 모두 일정
  - n-1, n-2, … , 2, 1 번 = n(n-1)/2
- 교환 횟수
  - 입력 자료가 역순으로 정렬되어 있는 최악의 경우, 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 (비교 횟수 * 3) 번 = 3n(n-1)/2
  - 입력 자료가 이미 정렬되어 있는 최상의 경우, 자료의 이동이 발생하지 않는다.
- T(n) = O(n^2)

#### 버블 정렬 js 코드

```js
function solution(arr){
    let answer=arr;
    // 맨 마지막 까지 회전을 돌 필요가 없으므로 배열 길이 - 1만큼 반복
    for (let i = 0; i < arr.length - 1; i++) {
        // 회전이 진행될 수록 뒤에서부터 값이 결정되므로 배열 길이 - 회전 - 1만큼 반복
        for (let j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
            }
        }
    }
    return answer;
}

let arr=[7, 4, 5, 1, 3];
console.log(solution(arr));
```



마지막으로 선택정렬과 버블정렬을 비교하자면, 둘디 시간복잡도는 O(n^2)로 동일하지만 시간에 있어서 **선택 정렬은 버블 정렬보다 항상 우수**하다.
