---
title:  "[개념공부] 선택정렬, 버블정렬, 삽입정렬"
permalink: /categories/algo_study/ssbsis
author_profile: true
categories:
  - 알고리즘 개념 정리
tags:
  - 알고리즘 개념 정리
toc: true
toc_label: "목차"
toc_icon: "bookmark"
last_modified_at: 2023-01-28
toc_sticky: true
---

 이번 포스팅에서는 여러가지 정렬 알고리즘 중 **선택정렬**과 **버블정렬**, **삽입정렬**에 대해 알아보겠다.



### 선택 정렬

> 입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법인 제자리 정렬 알고리즘 중의 하나로, 다음과 같은 순서로 이루어진다.

1. 주어진 리스트 중에 최소값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)).
3. 맨 처음 위치를 뺀 나머지 리스트에서 1, 2를 반복적으로 수행한다.

![img](../../assets/images/selection-sort.png)



#### 선택 정렬알고리즘의 특징

- 장점
  - 자료 이동 횟수가 미리 결정된다.
- 단점
  - 안정성을 만족하지 않는다.
  - 즉, 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다.



#### 선택 정렬의 시간복잡도

시간복잡도를 계산한다면

- 비교 횟수
  - 두 개의 for 루프의 실행 횟수
  - 외부 루프: (n-1)번
  - 내부 루프(최솟값 찾기): n-1, n-2, … , 2, 1 번
- 교환 횟수
  - 외부 루프의 실행 횟수와 동일. 즉, 상수 시간 작업
  - 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 3(n-1)번
- T(n) = (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = O(n^2)



#### 선택 정렬 js 코드

```js
function solution(arr){
    let answer=arr;
    for (let i = 0; i < arr.length; i++) {
        let minIdx = i
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIdx]) minIdx = j
        }
        [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
    }
    return answer;
}

let arr=[13, 5, 11, 7, 23, 15];
console.log(solution(arr));
```

----



### 버블 정렬

>  원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어진 이름이다. 기본적으로 배열의 두 수(a, b)를 선택한 뒤, 만약 그 두 수가 정렬되었다면 놔두고 아니라면 두 수를 바꾸는 방식으로 진행된다. 오름차순으로 정렬할 때는 a <  b여야  내림차순이라면 a > b여야 정렬된 것으로 판단한다.



#### 버블 정렬의 구체적인 개념

- 버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
- **1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동**하므로 **2회전에서는 맨 끝에 있는 자료는 정렬에서 제외**되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

![img](../../assets/images/bubble-sort.png)



#### 버블 정렬 알고리즘의 특징

- 장점
  - 구현이 매우 간단하다.
- 단점
  - 순서에 맞지 않은 요소를 인접한 요소와 교환한다.
  - 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
  - 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.
- 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 **더 복잡**하기 때문에 버블 정렬은 단순성에도 불구하고 **거의 쓰이지 않는다**.



#### 버블 정렬의 시간복잡도

시간복잡도를 계산한다면

- 비교 횟수
  - 최상, 평균, 최악 모두 일정
  - n-1, n-2, … , 2, 1 번 = n(n-1)/2
- 교환 횟수
  - 입력 자료가 역순으로 정렬되어 있는 최악의 경우, 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 (비교 횟수 * 3) 번 = 3n(n-1)/2
  - 입력 자료가 이미 정렬되어 있는 최상의 경우, 자료의 이동이 발생하지 않는다.
- T(n) = O(n^2)

#### 버블 정렬 js 코드

```js
function solution(arr){
    let answer=arr;
    // 맨 마지막 까지 회전을 돌 필요가 없으므로 배열 길이 - 1만큼 반복
    for (let i = 0; i < arr.length - 1; i++) {
        // 회전이 진행될 수록 뒤에서부터 값이 결정되므로 배열 길이 - 회전 - 1만큼 반복
        for (let j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
            }
        }
    }
    return answer;
}

let arr=[7, 4, 5, 1, 3];
console.log(solution(arr));
```



선택정렬과 버블정렬을 비교하자면, 둘디 시간복잡도는 O(n^2)로 동일하지만 시간에 있어서 **선택 정렬은 버블 정렬보다 항상 우수**하다.



### 삽입 정렬

>  삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.



#### 삽입 정렬의 구체적인 개념

- 처음 Key 값은 **두번째 자료부터 시작**한다.
- 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교하는 식으로 앞에 있는 자료들과 차례대로 비교하며 앞에 있는 자료가 더 작을때 까지 찾는다.
- 더 이상 앞에있는 자료가 크지 않다면 자료가 삽입될 위치이며, 그 위치에 자료를 삽입하기 위해 비교했던 자료를 한 칸씩 뒤로 이동시킨다.

![img](../../assets/images/insertion-sort.png)



#### 삽입 정렬 알고리즘의 특징

- 장점
  - 안정한 정렬 방법
  - 레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.
  - 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.
- 단점
  - 비교적 많은 레코드들의 이동을 포함한다.
  - 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.



#### 삽입 정렬의 시간복잡도

시간복잡도를 계산한다면

- 최선의 경우
  - 비교 횟수
    - 이동 없이 1번의 비교만 이루어진다.
    - 외부 루프: (n-1)번
  - Best T(n) = O(n)
- 최악의 경우(입력 자료가 역순일 경우)
  - 비교 횟수
    - 외부 루프 안의 각 반복마다 i번의 비교 수행
    - 외부 루프: (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = O(n^2)
  - 교환 횟수
    - 외부 루프의 각 단계마다 (i+2)번의 이동 발생
    - n(n-1)/2 + 2(n-1) = (n^2+3n-4)/2 = O(n^2)
  - Worst T(n) = O(n^2)

#### 삽입 정렬 js 코드

```js
function solution(arr){
    let answer=arr;
    // 두번째 자료부터 시작 하므로 1번 인덱스부터 시작
    for (let i = 1; i < arr.length; i++) {
        // 두번째 자료의 값을 저장해두고, 변수 j 생성
        let tmp = arr[i], j;
        // 현재 i값에 해당하는 자료의 앞쪽 숫자들과 비교하기
        for (j = i - 1; j >= 0; j--) {
            // 만약 앞에 있는 자료가 더 크다면, 앞에 있는 자료를 뒤로 한칸 땡겨주고
            if (arr[j] > tmp) arr[j + 1] = arr[j]
            else break
        }
        // 그 자리에 tmp 값 넣어주기.
        arr[j + 1] = tmp
    }
    return answer;
}

let arr=[7, 4, 5, 1, 3];
console.log(solution(arr));
```



마지막으로 선택정렬과 버블정렬, 삽입정렬을 비교하자면, 셋 다 시간복잡도는 O(n^2)로 동일하지만 시간에 있어서 **삽입정렬 > 선택정렬 > 버블정렬 순으로 우수**하다.
