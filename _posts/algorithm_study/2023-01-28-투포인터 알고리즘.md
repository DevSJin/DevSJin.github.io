---
title:  "[개념공부] 투 포인터 알고리즘(Two-Pointers Algorithm)"
permalink: /categories/algo_study/twopointer
author_profile: true
categories:
  - 알고리즘 개념 정리
tags:
  - 알고리즘 개념 정리
toc: true
toc_label: "목차"
toc_icon: "bookmark"
last_modified_at: 2023-01-28
toc_sticky: true
---

 오늘은 최근에 문제를 풀면서 새롭게 알게 된 개념인 `투 포인터 알고리즘`에 대해 알아보자. 



### 투 포인터 알고리즘

>  투 포인터 알고리즘은 말 그대로 두 개의 포인터를 이용해 문제를 해결하는 알고리즘을 뜻한다. 보통 배열 상에서 왼쪽 l(left), 오른쪽 r(right)이나 시작점s(start), 끝나는 지점e(end) 같은 식으로 포인터의 이름을 붙인다. 혹은 p1, p2와 같이 투 포인터로 이름을 적기도 한다.

투 포인터 알고리즘을 설명하기 위해, 정말 간단한 문제 한 가지를 먼저 소개해 보겠다.



#### 배열 합치기 문제

오름차순으로 정렬이 된 두 배열이 주어지면 두 배열을 합쳐 오름차순으로 출력하는 프로그램 을 작성하세요. 

##### ▣ 입력설명 

첫 번째 줄에 N(1<=N<=100)개의 배열 원소가 오름차순으로 주어집니다.  

세 번째 줄에 두 번째 배열의 크기 이 주어집니다. 

두 번째 줄에 M(1<=M<=100)개의 배열 원소가 오름차순으로 주어집니다. 

각 리스트의 원소는 int형 변수의 크기를 넘지 않습니다. 

##### ▣ 출력설명 

오름차순으로 정렬된 배열을 출력합니다. 

##### ▣ 입력예제 

1 3 5 

2 3 6 7 9 

##### ▣ 출력예제  

1 2 3 3 5 6 7 

 사실 위와같은 문제는, 두 배열을 합친 뒤 sort() 메소드를 쓰면 금방 해결할 수 있지만, sort() 메서드는 시간복잡도가 O(nlogn)으로 n값이 커질수록 속도가 느려지는 단점이 있다. 그래서 우리는 반복문을 한번만 돌아 O(n)의 시간복잡도를 갖는 투포인터 알고리즘을 활용해 볼 것이다.

위 문제를 해결하는 아이디어는 다음과 같다.

```markdown
1. 두 배열의 포인터를 p1=p2=0으로 설정한다.
2. p1과 p2인덱스에 있는 숫자를 비교한 후, 더 작거나 같은 수를 새로운 배열에 집어넣고, 해당 숫자에 있는 포인터를 1 증가시킨다.
3. 포인터가 아직 배열의 길이만큼 가지 못한 배열의 남아있는 숫자들을 차례로 배열에 넣어주기.
```

위를 코드로 구현하면 다음과 같다.

```js
function solution(arr1, arr2) {
    let res = []
    let p1 = p2 = 0
    let n = arr1.length, m = arr2.length
 
    while (p1 < n && p2 < m) {
        if (arr1[p1] <= arr2[p2]) res.push(arr1[p1++])
        else res.push(arr2[p2++])
    }
    while (p1 < n) res.push(arr1[p1++])
    while (p2 < m) res.push(arr2[p2++])
    
    return res
}
let arr1 = [1, 3, 5]
let arr2 = [2, 3, 6, 7, 9]
console.log(solution(arr1, arr2)) //[1, 2, 3, 3, 5, 6, 7, 9]
```

위 문제보다 투포인터 알고리즘이 더 자주 사용되는 문제가 바로 연속부분수열 문제인데, 예제를 하나 더 살펴보겠다.



#### 연속 부분 수열 문제

N개의 수로 이루어진 수열이 주어집니다. 이 수열에서 연속부분수열의 합이 특정숫자 M이 되는 경우가 몇 번 있는지 구하는 프로그램을  작성하세요. 만약 N=8, M=6이고 수열이 다음과 같다면 1 2 1 3 1 1 1 2  합이 6이 되는 연속부분수열은 {2, 1, 3}, {1, 3, 1, 1}, {3, 1, 1, 1}로 총 3가지입니다.

##### ▣ 입력설명 

첫째 줄에 N(1≤N≤100,000), M(1≤M≤100,000,000)이 주어진다.  수열의 원소값은 1,000을 넘지 않는 자연수이다.

##### ▣ 출력설명 

첫째 줄에 경우의 수를 출력한다.

##### ▣ 입력예제 

8 6 

1 2 1 3 1 1 1 2

##### ▣ 출력예제  

3

위 문제를 해결하는 아이디어는 다음과 같고, 이는 **연속부분수열**이기 때문에 가능하다.

```markdown
1. l 포인트를 0으로 시작하고, for문을 통해 r을 1씩 증가시키면서 해당 인덱스에 맞는 수를 sum에 더해준다.
2. sum === m이면 카운트 해주고,
3. 만약 sum이 m값보다 크거나 같다면 l인덱스에 숫자를 빼주면서 l자체를 1 증가시킨다.
```

만약 위 아이디어만으로 이해가 가지 않는다면, [투포인터 알고리즘](https://code-lab1.tistory.com/276) 글에서 중간쯤 그림으로 잘 설명이 되어있으니 방문해보자.

그럼 이제 위 아이디어를 코드로 작성해보자.

```js
function solution(n, m, arr) {
    let res = 0, sum = 0, l = 0

    for (let r = 0; r < n; r++) {
        sum += arr[r]
        if(sum === m) res++
        while (sum >= m) {
            sum -= arr[l++]
            if (sum === m) res++
        }
    }
    return res
}
let arr = [1, 2, 1, 3, 1, 1, 1, 2]
console.log(solution(8, 6, arr))
```

지금까지 투포인터 알고리즘을 알아봤다. 문제를 풀다가 반복문으로 도저히 시간안에 해결이 안되는 문제일 때 투포인터 알고리즘을 떠올려 문제를 해결할 수 있다면 좋을 것 같다.
