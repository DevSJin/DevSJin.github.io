---
title:  "[이것이 코딩 테스트다] 큰 수의 법칙"
permalink: /categories/algo_etc/practice1
author_profile: true
categories:
  - 이코테 연습문제
tags:
  - 그리디 알고리즘
toc: true
toc_label: "목차"
toc_icon: "bookmark"
last_modified_at: 2022-12-09
toc_sticky: true 
---

## 문제

> 문제의 저작권은 ‘이것이 코딩테스트다’ 교재에 있습니다.



다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙.

단 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없다.

 

예를 들어 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때, M이 8이고, K가 3이라면 

```
6 + 6 + 6 + 5 + 6 + 6 + 6 + 5  => 46
```

단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.

예를 들어 순서대로 3, 4, 3, 4, 3 으로 이루어진 배열이 있을 때 M이 7이고, K가 2라고 가정하자

```
4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 => 28
```



#### 입력 조건

- 첫째 줄에 N(2 <= N <= 1000), M( 1 <= M <= 10,000), K(1 <= K <= 10,000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10,000이하의 수로 주어진다.
- 입력으로 주어지는 K는 항상 M보다 작거나 같다.

 

#### 출력 조건

- 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

 

#### 입력 예시

> 5 8 3
> 2 4 5 4 6

 

#### 출력 예시

> 46

 

### 접근방식

전형적인 그리디 알고리즘이다.

입력값 중에서 카장 큰 수와 두번째로 큰 수만 가지고 답을 출력할 수 있다. 연속으로 더할 수 있는 횟수가 K번 이므로, '가장 큰 수를 K번 더하고 두번째로 큰 수를 1번 더하는 연산'을 반복한다.

```python
# N은 자연수의 개수, M은 연산 횟수, K는 연속으로 더할 수 있는 횟수
N, M, K = map(int, input().split())
              
# 자연수를 배열로 받아서 저장하기
data = list(map(int, input(), split()))

data.sort() # 배열을 정렬해주기
first = data[N - 1] # 가장 큰 수
second = data[N - 2] # 두 번째로 큰 수

result = 0 #결과값을 미리 선언해두기

while True:
    for i in range(K): #가장 큰 수를 K번 더해주기
        if M == 0: # M이 0이 되면 for문 탈출
            break
        result += first
        M -= 1
    if M == 0:
        break # M이 0이 되면 While문 탈출
    result += second # 두번째로 큰 수를 한번만 더해주기
    M -= 1 #마찬가지로 더할때마다 M 카운트 1씩 빼주기

print(result)
    
```



### 접근방식2

해당 문제는 M이 10000 이하이므로 반복문을 사용해서 문제를 해결할 수 있지만, M의 크기가 커진다면 시간초과를 할 수도 있다. 따라서 수학적 아이디어를 이용해 좀 더 효율적으로 문제를 해결할 수 있다. 

입력값이 다음과 같을 때

> 5 8 3
> 2 4 5 4 6

(6 + 6 + 6 + 5) 의 수 식이 2번 반복되는데, 이때 반복되는 수열의 길이는 K + 1(여기서는 4)이다.

따라서 M을 K + 1로 나눈 몫( 8 / 4 = 2)이 수열이 반복되는 횟수가 된다. 다만 고려해야 할 점은 M이 K + 1 로 딱 나누어 떨어지지 않는 경우가 있다는 것이다. 이때는 M을 (K + 1)로 나눈 나머지 만큼 가장 큰 수를 추가로 더해주면 된다.  이를 토대로 답안을 작성하면

```python
# N은 자연수의 개수, M은 연산 횟수, K는 연속으로 더할 수 있는 횟수
N, M, K = map(int, input().split())
              
# 자연수를 배열로 받아서 저장하기
data = list(map(int, input(), split()))

data.sort() # 배열을 정렬해주기
first = data[N - 1] # 가장 큰 수
second = data[N - 2] # 두 번째로 큰 수

#가장 큰 수가 더해지는 횟수 계산
count = int(M / (K + 1) * K) 
count += M % (K + 1)

result = 0
result += (count) * first #가장 큰 수 더하기
result += (M - count) * second #두번째로 큰 수 더하기

print(result)
```



